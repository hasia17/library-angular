import { HttpResponse } from '@angular/common/http';
import { tap } from 'rxjs/operators';
import { HttpProgressLoaderService } from './http-progress-loader.service';
import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "./http-progress-loader.service";
export class HttpProgressInterceptor {
    constructor(loaderService) {
        this.loaderService = loaderService;
        this.requests = [];
    }
    removeRequest(req) {
        const i = this.requests.indexOf(req);
        if (i >= 0) {
            this.requests.splice(i, 1);
        }
        this.loaderService.isLoading.next(this.requests.length > 0);
    }
    intercept(req, next) {
        const started = Date.now();
        this.requests.push(req);
        this.loaderService.isLoading.next(true);
        return next.handle(req).pipe(tap(event => {
            if (event instanceof HttpResponse) {
                const elapsed = Date.now() - started;
                console.log(`Request for ${req.urlWithParams} took ${elapsed} ms with result ${event.status}. ${this.requests.length}`);
                this.removeRequest(req);
            }
        }, error => {
            console.log(`Http err: status ${error.status} ${JSON.stringify(error)}`);
            this.removeRequest(req);
        }));
    }
}
HttpProgressInterceptor.ɵprov = i0.ɵɵdefineInjectable({ factory: function HttpProgressInterceptor_Factory() { return new HttpProgressInterceptor(i0.ɵɵinject(i1.HttpProgressLoaderService)); }, token: HttpProgressInterceptor, providedIn: "root" });
HttpProgressInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
HttpProgressInterceptor.ctorParameters = () => [
    { type: HttpProgressLoaderService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHR0cC1wcm9ncmVzcy1pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3BvcnRhbC1saWIvc3JjL2xpYi90a2l0LXBvcnRhbC9odHRwLXByb2dyZXNzLWludGVyY2VwdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBd0QsWUFBWSxFQUFFLE1BQU0sc0JBQXNCLENBQUE7QUFFekcsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFBO0FBQ3BDLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLGdDQUFnQyxDQUFBO0FBQzFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUE7OztBQUcxQyxNQUFNLE9BQU8sdUJBQXVCO0lBRWxDLFlBQW9CLGFBQXdDO1FBQXhDLGtCQUFhLEdBQWIsYUFBYSxDQUEyQjtRQURwRCxhQUFRLEdBQXVCLEVBQUUsQ0FBQTtJQUNzQixDQUFDO0lBRWhFLGFBQWEsQ0FBQyxHQUFxQjtRQUNqQyxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQTtRQUNwQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDVixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7U0FDM0I7UUFDRCxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUE7SUFDN0QsQ0FBQztJQUNELFNBQVMsQ0FBQyxHQUFxQixFQUFFLElBQWlCO1FBQ2hELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQTtRQUMxQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQTtRQUN2QixJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7UUFDdkMsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FDMUIsR0FBRyxDQUNELEtBQUssQ0FBQyxFQUFFO1lBQ04sSUFBSSxLQUFLLFlBQVksWUFBWSxFQUFFO2dCQUNqQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsT0FBTyxDQUFBO2dCQUNwQyxPQUFPLENBQUMsR0FBRyxDQUNULGVBQWUsR0FBRyxDQUFDLGFBQWEsU0FBUyxPQUFPLG1CQUFtQixLQUFLLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQzNHLENBQUE7Z0JBQ0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQTthQUN4QjtRQUNILENBQUMsRUFDRCxLQUFLLENBQUMsRUFBRTtZQUNOLE9BQU8sQ0FBQyxHQUFHLENBQUMsb0JBQW9CLEtBQUssQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUE7WUFDeEUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQTtRQUN6QixDQUFDLENBQ0YsQ0FDRixDQUFBO0lBQ0gsQ0FBQzs7OztZQWpDRixVQUFVLFNBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFOzs7WUFIekIseUJBQXlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSHR0cEludGVyY2VwdG9yLCBIdHRwSGFuZGxlciwgSHR0cFJlcXVlc3QsIEh0dHBFdmVudCwgSHR0cFJlc3BvbnNlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcydcbmltcG9ydCB7IHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJ1xuaW1wb3J0IHsgSHR0cFByb2dyZXNzTG9hZGVyU2VydmljZSB9IGZyb20gJy4vaHR0cC1wcm9ncmVzcy1sb2FkZXIuc2VydmljZSdcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJ1xuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIEh0dHBQcm9ncmVzc0ludGVyY2VwdG9yIGltcGxlbWVudHMgSHR0cEludGVyY2VwdG9yIHtcbiAgcHJpdmF0ZSByZXF1ZXN0czogSHR0cFJlcXVlc3Q8YW55PltdID0gW11cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBsb2FkZXJTZXJ2aWNlOiBIdHRwUHJvZ3Jlc3NMb2FkZXJTZXJ2aWNlKSB7fVxuXG4gIHJlbW92ZVJlcXVlc3QocmVxOiBIdHRwUmVxdWVzdDxhbnk+KSB7XG4gICAgY29uc3QgaSA9IHRoaXMucmVxdWVzdHMuaW5kZXhPZihyZXEpXG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5yZXF1ZXN0cy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gICAgdGhpcy5sb2FkZXJTZXJ2aWNlLmlzTG9hZGluZy5uZXh0KHRoaXMucmVxdWVzdHMubGVuZ3RoID4gMClcbiAgfVxuICBpbnRlcmNlcHQocmVxOiBIdHRwUmVxdWVzdDxhbnk+LCBuZXh0OiBIdHRwSGFuZGxlcik6IE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+IHtcbiAgICBjb25zdCBzdGFydGVkID0gRGF0ZS5ub3coKVxuICAgIHRoaXMucmVxdWVzdHMucHVzaChyZXEpXG4gICAgdGhpcy5sb2FkZXJTZXJ2aWNlLmlzTG9hZGluZy5uZXh0KHRydWUpXG4gICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcSkucGlwZShcbiAgICAgIHRhcChcbiAgICAgICAgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEh0dHBSZXNwb25zZSkge1xuICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSBzdGFydGVkXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYFJlcXVlc3QgZm9yICR7cmVxLnVybFdpdGhQYXJhbXN9IHRvb2sgJHtlbGFwc2VkfSBtcyB3aXRoIHJlc3VsdCAke2V2ZW50LnN0YXR1c30uICR7dGhpcy5yZXF1ZXN0cy5sZW5ndGh9YFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVSZXF1ZXN0KHJlcSlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgSHR0cCBlcnI6IHN0YXR1cyAke2Vycm9yLnN0YXR1c30gJHtKU09OLnN0cmluZ2lmeShlcnJvcil9YClcbiAgICAgICAgICB0aGlzLnJlbW92ZVJlcXVlc3QocmVxKVxuICAgICAgICB9XG4gICAgICApXG4gICAgKVxuICB9XG59XG4iXX0=