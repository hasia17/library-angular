import { HttpClient } from '@angular/common/http';
import { Injectable, Inject } from '@angular/core';
import { APP_CONFIG } from './injection-tokens';
import { PortalApiService } from './services/portal-api.service';
import { ReplaySubject } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
import * as i2 from "./services/portal-api.service";
import * as i3 from "./injection-tokens";
const TKIT_PORTAL_ID = 'TKIT_PORTAL_ID';
export class ConfigurationService {
    constructor(http, portalService, appConfig) {
        this.http = http;
        this.portalService = portalService;
        this.appConfig = appConfig;
        this.lang$ = new ReplaySubject(1);
    }
    init() {
        return new Promise((resolve, reject) => {
            if (this.appConfig.skipRemoteConfigLoad) {
                console.log('TKA001: Remote config load is disabled. To enable it, remove the "skipRemoteConfigLoad" key in your environemnt.json');
                this.customEnv = this.appConfig;
                resolve(false);
            }
            let loadConfigPromise;
            // if we have Backend env vars injected in HTML, use it
            console.log(`ENV resolved ${window['APP_CONFIG']}`);
            if (window['APP_CONFIG']) {
                loadConfigPromise = new Promise((resolve, reject) => {
                    resolve(window['APP_CONFIG']);
                });
            }
            else {
                console.log('noooo moar http');
                //otherwise fetch them from env.json
                loadConfigPromise = this.http.get(this.appConfig.remoteConfigURL || 'assets/env.json').toPromise();
            }
            loadConfigPromise
                .then(config => {
                if (config) {
                    const sanitizedEnvValues = this.sanitizeConfig(config);
                    this.customEnv = Object.assign(Object.assign({}, this.appConfig), sanitizedEnvValues);
                }
            })
                .then(() => {
                const portalId = this.customEnv[TKIT_PORTAL_ID] || 'PORTAL';
                this.portalService
                    .getPortalData(portalId)
                    .toPromise()
                    .then(data => {
                    if (data) {
                        this.portalData = data;
                    }
                    resolve(true);
                })
                    .catch(err => {
                    console.log(`Failed to load portal data! ${JSON.stringify(err)}`);
                    this.portalData = { portalId: 'PORTAL' };
                    resolve(true);
                });
            })
                .catch(e => {
                console.log(`Failed to load env configuration`);
                reject(e);
            });
        });
    }
    sanitizeConfig(config) {
        return (Object.keys(config)
            // only take values that are interpolated/set
            .filter(key => !config[key].startsWith('${'))
            .reduce((obj, key) => {
            obj[key] = config[key];
            return obj;
        }, {}));
    }
    getProperty(key) {
        return this.customEnv[key];
    }
    getPortalData() {
        return this.portalData;
    }
    setLang(lang) {
        console.log('[CONFIG SERVICE] SETTING LANG: ', lang);
        this.lang$.next(lang);
    }
}
ConfigurationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ConfigurationService_Factory() { return new ConfigurationService(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.PortalApiService), i0.ɵɵinject(i3.APP_CONFIG)); }, token: ConfigurationService, providedIn: "root" });
ConfigurationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
ConfigurationService.ctorParameters = () => [
    { type: HttpClient },
    { type: PortalApiService },
    { type: undefined, decorators: [{ type: Inject, args: [APP_CONFIG,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZmlndXJhdGlvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvcG9ydGFsLWxpYi9zcmMvbGliL2FwaS9jb25maWd1cmF0aW9uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFBO0FBQ2pELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFBO0FBQ2xELE9BQU8sRUFBRSxVQUFVLEVBQWEsTUFBTSxvQkFBb0IsQ0FBQTtBQUMxRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQTtBQUVoRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sTUFBTSxDQUFBOzs7OztBQUVwQyxNQUFNLGNBQWMsR0FBRyxnQkFBZ0IsQ0FBQTtBQUt2QyxNQUFNLE9BQU8sb0JBQW9CO0lBTy9CLFlBQ1UsSUFBZ0IsRUFDaEIsYUFBK0IsRUFDWCxTQUFvQjtRQUZ4QyxTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLGtCQUFhLEdBQWIsYUFBYSxDQUFrQjtRQUNYLGNBQVMsR0FBVCxTQUFTLENBQVc7UUFUM0MsVUFBSyxHQUFHLElBQUksYUFBYSxDQUFTLENBQUMsQ0FBQyxDQUFBO0lBVXhDLENBQUM7SUFFRyxJQUFJO1FBQ1QsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtZQUNyQyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsb0JBQW9CLEVBQUU7Z0JBQ3ZDLE9BQU8sQ0FBQyxHQUFHLENBQ1Qsc0hBQXNILENBQ3ZILENBQUE7Z0JBQ0QsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFBO2dCQUMvQixPQUFPLENBQUMsS0FBSyxDQUFDLENBQUE7YUFDZjtZQUNELElBQUksaUJBQStCLENBQUE7WUFDbkMsdURBQXVE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QUMsSUFBWTtRQUN6QixPQUFPLENBQUMsR0FBRyxDQUFDLGlDQUFpQyxFQUFFLElBQUksQ0FBQyxDQUFBO1FBQ3BELElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO0lBQ3ZCLENBQUM7Ozs7WUE1RkYsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7WUFYUSxVQUFVO1lBR1YsZ0JBQWdCOzRDQW1CcEIsTUFBTSxTQUFDLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJ1xuaW1wb3J0IHsgQVBQX0NPTkZJRywgTGliQ29uZmlnIH0gZnJvbSAnLi9pbmplY3Rpb24tdG9rZW5zJ1xuaW1wb3J0IHsgUG9ydGFsQXBpU2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvcG9ydGFsLWFwaS5zZXJ2aWNlJ1xuaW1wb3J0IHsgUG9ydGFsIH0gZnJvbSAnLi9tb2RlbC9wb3J0YWwnXG5pbXBvcnQgeyBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcydcblxuY29uc3QgVEtJVF9QT1JUQUxfSUQgPSAnVEtJVF9QT1JUQUxfSUQnXG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBDb25maWd1cmF0aW9uU2VydmljZSB7XG4gIHB1YmxpYyBsYW5nJCA9IG5ldyBSZXBsYXlTdWJqZWN0PHN0cmluZz4oMSlcblxuICBwcml2YXRlIGN1c3RvbUVudjogYW55XG4gIHByaXZhdGUgcG9ydGFsRGF0YTogUG9ydGFsXG4gIGVycm9yOiBhbnlcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGh0dHA6IEh0dHBDbGllbnQsXG4gICAgcHJpdmF0ZSBwb3J0YWxTZXJ2aWNlOiBQb3J0YWxBcGlTZXJ2aWNlLFxuICAgIEBJbmplY3QoQVBQX0NPTkZJRykgcHJpdmF0ZSBhcHBDb25maWc6IExpYkNvbmZpZ1xuICApIHt9XG5cbiAgcHVibGljIGluaXQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLmFwcENvbmZpZy5za2lwUmVtb3RlQ29uZmlnTG9hZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAnVEtBMDAxOiBSZW1vdGUgY29uZmlnIGxvYWQgaXMgZGlzYWJsZWQuIFRvIGVuYWJsZSBpdCwgcmVtb3ZlIHRoZSBcInNraXBSZW1vdGVDb25maWdMb2FkXCIga2V5IGluIHlvdXIgZW52aXJvbmVtbnQuanNvbidcbiAgICAgICAgKVxuICAgICAgICB0aGlzLmN1c3RvbUVudiA9IHRoaXMuYXBwQ29uZmlnXG4gICAgICAgIHJlc29sdmUoZmFsc2UpXG4gICAgICB9XG4gICAgICBsZXQgbG9hZENvbmZpZ1Byb21pc2U6IFByb21pc2U8YW55PlxuICAgICAgLy8gaWYgd2UgaGF2ZSBCYWNrZW5kIGVudiB2YXJzIGluamVjdGVkIGluIEhUTUwsIHVzZSBpdFxuICAgICAgY29uc29sZS5sb2coYEVOViByZXNvbHZlZCAke3dpbmRvd1snQVBQX0NPTkZJRyddfWApXG4gICAgICBpZiAod2luZG93WydBUFBfQ09ORklHJ10pIHtcbiAgICAgICAgbG9hZENvbmZpZ1Byb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSh3aW5kb3dbJ0FQUF9DT05GSUcnXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdub29vbyBtb2FyIGh0dHAnKVxuICAgICAgICAvL290aGVyd2lzZSBmZXRjaCB0aGVtIGZyb20gZW52Lmpzb25cbiAgICAgICAgbG9hZENvbmZpZ1Byb21pc2UgPSB0aGlzLmh0dHAuZ2V0KHRoaXMuYXBwQ29uZmlnLnJlbW90ZUNvbmZpZ1VSTCB8fCAnYXNzZXRzL2Vudi5qc29uJykudG9Qcm9taXNlKClcbiAgICAgIH1cblxuICAgICAgbG9hZENvbmZpZ1Byb21pc2VcbiAgICAgICAgLnRoZW4oY29uZmlnID0+IHtcbiAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRFbnZWYWx1ZXMgPSB0aGlzLnNhbml0aXplQ29uZmlnKGNvbmZpZylcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tRW52ID0geyAuLi50aGlzLmFwcENvbmZpZywgLi4uc2FuaXRpemVkRW52VmFsdWVzIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBwb3J0YWxJZCA9IHRoaXMuY3VzdG9tRW52W1RLSVRfUE9SVEFMX0lEXSB8fCAnUE9SVEFMJ1xuXG4gICAgICAgICAgdGhpcy5wb3J0YWxTZXJ2aWNlXG4gICAgICAgICAgICAuZ2V0UG9ydGFsRGF0YShwb3J0YWxJZClcbiAgICAgICAgICAgIC50b1Byb21pc2UoKVxuICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0YWxEYXRhID0gZGF0YVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZhaWxlZCB0byBsb2FkIHBvcnRhbCBkYXRhISAke0pTT04uc3RyaW5naWZ5KGVycil9YClcbiAgICAgICAgICAgICAgdGhpcy5wb3J0YWxEYXRhID0geyBwb3J0YWxJZDogJ1BPUlRBTCcgfVxuICAgICAgICAgICAgICByZXNvbHZlKHRydWUpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEZhaWxlZCB0byBsb2FkIGVudiBjb25maWd1cmF0aW9uYClcbiAgICAgICAgICByZWplY3QoZSlcbiAgICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBzYW5pdGl6ZUNvbmZpZyhjb25maWc6IE9iamVjdCkge1xuICAgIHJldHVybiAoXG4gICAgICBPYmplY3Qua2V5cyhjb25maWcpXG4gICAgICAgIC8vIG9ubHkgdGFrZSB2YWx1ZXMgdGhhdCBhcmUgaW50ZXJwb2xhdGVkL3NldFxuICAgICAgICAuZmlsdGVyKGtleSA9PiAhKGNvbmZpZ1trZXldIGFzIHN0cmluZykuc3RhcnRzV2l0aCgnJHsnKSlcbiAgICAgICAgLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcbiAgICAgICAgICBvYmpba2V5XSA9IGNvbmZpZ1trZXldXG4gICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICB9LCB7fSlcbiAgICApXG4gIH1cblxuICBwdWJsaWMgZ2V0UHJvcGVydHkoa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmN1c3RvbUVudltrZXldXG4gIH1cblxuICBwdWJsaWMgZ2V0UG9ydGFsRGF0YSgpOiBQb3J0YWwge1xuICAgIHJldHVybiB0aGlzLnBvcnRhbERhdGFcbiAgfVxuICBwdWJsaWMgc2V0TGFuZyhsYW5nOiBzdHJpbmcpIHtcbiAgICBjb25zb2xlLmxvZygnW0NPTkZJRyBTRVJWSUNFXSBTRVRUSU5HIExBTkc6ICcsIGxhbmcpXG4gICAgdGhpcy5sYW5nJC5uZXh0KGxhbmcpXG4gIH1cbn1cbiJdfQ==