import { of } from 'rxjs';
import { finalize, share, tap } from 'rxjs/operators';
import { HttpResponse, HttpParams, HTTP_INTERCEPTORS } from '@angular/common/http';
import { InjectionToken, Injectable, Inject, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/keySerializer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
import * as ɵngcc0 from '@angular/core';
class KeySerializer {
}
class DefaultKeySerializer extends KeySerializer {
    /**
     * @param {?} request
     * @return {?}
     */
    serialize(request) {
        return request.customKey || request.urlWithParams;
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/httpCacheConfig.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultConfig = {
    strategy: 'explicit',
    ttl: 3600000,
    // One hour
    localStorageKey: 'httpCache'
};
/**
 * @param {?=} params
 * @return {?}
 */
function withCache(params = {}) {
    return {
        params: Object.assign({ cache$: true }, params)
    };
}
/**
 * @param {?=} config
 * @return {?}
 */
function cashewConfig(config = defaultConfig) {
    return {
        strategy: config.strategy || defaultConfig.strategy,
        ttl: config.ttl || defaultConfig.ttl,
        localStorageKey: config.localStorageKey || defaultConfig.localStorageKey,
        responseSerializer: config.responseSerializer,
        parameterCodec: config.parameterCodec
    };
}
/** @type {?} */
const HTTP_CACHE_CONFIG = new InjectionToken('HTTP_CACHE_CONFIG');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/deleteByRegex.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} pattern
 * @param {?} cache
 * @return {?}
 */
function deleteByRegex(pattern, cache) {
    for (const [key] of Array.from(cache)) {
        if (((/** @type {?} */ (pattern))).test(key)) {
            cache.delete(key);
            break;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/httpCacheStorage.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class HttpCacheStorage {
}
class DefaultHttpCacheStorage {
    constructor() {
        this.cache = new Map();
    }
    /**
     * @param {?} key
     * @return {?}
     */
    has(key) {
        return this.cache.has(key);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    get(key) {
        return this.cache.get(key);
    }
    /**
     * @param {?} key
     * @param {?} response
     * @return {?}
     */
    set(key, response) {
        this.cache.set(key, response);
    }
    /**
     * @param {?=} key
     * @return {?}
     */
    delete(key) {
        if (!key) {
            this.cache.clear();
            return;
        }
        if (typeof key === 'string') {
            this.cache.delete((/** @type {?} */ (key)));
            return;
        }
        deleteByRegex((/** @type {?} */ (key)), this.cache);
    }
}
DefaultHttpCacheStorage.ɵfac = function DefaultHttpCacheStorage_Factory(t) { return new (t || DefaultHttpCacheStorage)(); };
DefaultHttpCacheStorage.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DefaultHttpCacheStorage, factory: DefaultHttpCacheStorage.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DefaultHttpCacheStorage, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ttlManager.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class TTLManager {
}
class DefaultTTLManager {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
        this.cache = new Map();
    }
    /**
     * @param {?} key
     * @return {?}
     */
    isValid(key) {
        return this.cache.get(key) > new Date().getTime();
    }
    /**
     * @param {?} key
     * @param {?=} ttl
     * @return {?}
     */
    set(key, ttl) {
        /** @type {?} */
        let resolveTTL = ttl || this.config.ttl;
        this.cache.set(key, new Date().setMilliseconds(resolveTTL));
    }
    /**
     * @param {?=} key
     * @return {?}
     */
    delete(key) {
        if (!key) {
            this.cache.clear();
            return;
        }
        if (typeof key === 'string') {
            this.cache.delete((/** @type {?} */ (key)));
            return;
        }
        deleteByRegex((/** @type {?} */ (key)), this.cache);
    }
}
DefaultTTLManager.ɵfac = function DefaultTTLManager_Factory(t) { return new (t || DefaultTTLManager)(ɵngcc0.ɵɵinject(HTTP_CACHE_CONFIG)); };
DefaultTTLManager.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DefaultTTLManager, factory: DefaultTTLManager.ɵfac });
/** @nocollapse */
DefaultTTLManager.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [HTTP_CACHE_CONFIG,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DefaultTTLManager, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [HTTP_CACHE_CONFIG]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/httpCacheGuard.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class HttpCacheGuard {
}
class DefaultHttpCacheGuard {
    /**
     * @param {?} request
     * @return {?}
     */
    canActivate(request) {
        return request.method === 'GET' && request.responseType === 'json';
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/requestsQueue.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RequestsQueue {
    constructor() {
        this.queue = new Map();
    }
    /**
     * @param {?} key
     * @return {?}
     */
    get(key) {
        return this.queue.get(key);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    has(key) {
        return this.queue.has(key);
    }
    /**
     * @param {?} key
     * @param {?} shared
     * @return {?}
     */
    set(key, shared) {
        this.queue.set(key, shared);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    delete(key) {
        this.queue.delete(key);
    }
}
RequestsQueue.ɵfac = function RequestsQueue_Factory(t) { return new (t || RequestsQueue)(); };
RequestsQueue.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: RequestsQueue, factory: RequestsQueue.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RequestsQueue, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/cacheBucket.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CacheBucket {
    constructor() {
        this.keys = new Set();
    }
    /**
     * @param {?} key
     * @return {?}
     */
    add(key) {
        this.keys.add(key);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    has(key) {
        return this.keys.has(key);
    }
    /**
     * @param {?} cb
     * @return {?}
     */
    forEach(cb) {
        this.keys.forEach(cb);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    delete(key) {
        this.keys.delete(key);
    }
    /**
     * @return {?}
     */
    clear() {
        this.keys.clear();
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/httpCacheManager.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpCacheManager {
    /**
     * @param {?} queue
     * @param {?} storage
     * @param {?} guard
     * @param {?} ttlManager
     * @param {?} config
     */
    constructor(queue, storage, guard, ttlManager, config) {
        this.queue = queue;
        this.storage = storage;
        this.guard = guard;
        this.ttlManager = ttlManager;
        this.config = config;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    validate(key) {
        /** @type {?} */
        const has = this.storage.has(key);
        /** @type {?} */
        const isValid = this.ttlManager.isValid(key);
        if (has && isValid)
            return true;
        this.storage.delete(key);
        return false;
    }
    /**
     * @template T
     * @param {?} key
     * @return {?}
     */
    get(key) {
        return this._resolveResponse(this.storage.get(key));
    }
    /**
     * @param {?} key
     * @return {?}
     */
    has(key) {
        return this.storage.has(key);
    }
    /**
     * @param {?} key
     * @param {?} body
     * @param {?=} __2
     * @return {?}
     */
    set(key, body, { ttl, bucket } = {}) {
        /** @type {?} */
        let response = body;
        if (!(body instanceof HttpResponse)) {
            response = new HttpResponse({
                body,
                status: 200,
                url: key
            });
        }
        this._set(key, response, ttl);
        bucket && bucket.add(key);
    }
    /**
     * @param {?=} key
     * @return {?}
     */
    delete(key) {
        if (key instanceof CacheBucket) {
            key.forEach((/**
             * @param {?} value
             * @return {?}
             */
            value => this.delete(value)));
            key.clear();
            return;
        }
        this.storage.delete(key);
        this.ttlManager.delete(key);
    }
    /**
     * @return {?}
     */
    _getQueue() {
        return this.queue;
    }
    /**
     * @param {?} canActivate
     * @param {?} cache
     * @return {?}
     */
    _isCacheable(canActivate, cache) {
        /** @type {?} */
        const strategy = this.config.strategy;
        if (strategy === 'explicit') {
            return cache;
        }
        if (canActivate && strategy === 'implicit') {
            return cache !== false;
        }
        return false;
    }
    /**
     * @param {?} key
     * @param {?} response
     * @param {?} ttl
     * @return {?}
     */
    _set(key, response, ttl) {
        this.storage.set(key, response);
        this.ttlManager.set(key, ttl);
    }
    /**
     * @param {?} request
     * @return {?}
     */
    _canActivate(request) {
        return this.guard.canActivate(request);
    }
    /**
     * @template T
     * @param {?} event
     * @return {?}
     */
    _resolveResponse(event) {
        return this.config.responseSerializer ? event.clone({ body: this.config.responseSerializer(event.body) }) : event;
    }
}
HttpCacheManager.ɵfac = function HttpCacheManager_Factory(t) { return new (t || HttpCacheManager)(ɵngcc0.ɵɵinject(RequestsQueue), ɵngcc0.ɵɵinject(HttpCacheStorage), ɵngcc0.ɵɵinject(HttpCacheGuard), ɵngcc0.ɵɵinject(TTLManager), ɵngcc0.ɵɵinject(HTTP_CACHE_CONFIG)); };
HttpCacheManager.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: HttpCacheManager, factory: HttpCacheManager.ɵfac });
/** @nocollapse */
HttpCacheManager.ctorParameters = () => [
    { type: RequestsQueue },
    { type: HttpCacheStorage },
    { type: HttpCacheGuard },
    { type: TTLManager },
    { type: undefined, decorators: [{ type: Inject, args: [HTTP_CACHE_CONFIG,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HttpCacheManager, [{
        type: Injectable
    }], function () { return [{ type: RequestsQueue }, { type: HttpCacheStorage }, { type: HttpCacheGuard }, { type: TTLManager }, { type: undefined, decorators: [{
                type: Inject,
                args: [HTTP_CACHE_CONFIG]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/filterParams.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const filterKeys = ['ttl$', 'cache$', 'key$', 'bucket$', 'parameterCodec$'];
/**
 * @param {?} request
 * @return {?}
 */
function filterParams(request) {
    return request.params.keys().reduce((/**
     * @param {?} acc
     * @param {?} key
     * @return {?}
     */
    (acc, key) => {
        if (filterKeys.includes(key) === false) {
            acc[key] = request.params.getAll(key);
        }
        return acc;
    }), {});
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/cloneWithoutParams.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} request
 * @param {?} customKey
 * @param {?=} parameterCodec
 * @return {?}
 */
function cloneWithoutParams(request, customKey, parameterCodec) {
    /** @type {?} */
    const filteredParams = filterParams(request);
    /** @type {?} */
    const clone = request.clone({
        params: new HttpParams(Object.assign({ fromObject: filteredParams }, (parameterCodec && { encoder: parameterCodec })))
    });
    ((/** @type {?} */ (clone))).customKey = customKey;
    return (/** @type {?} */ (clone));
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/httpCacheInterceptor.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpCacheInterceptor {
    /**
     * @param {?} httpCacheManager
     * @param {?} keySerializer
     * @param {?} config
     */
    constructor(httpCacheManager, keySerializer, config) {
        this.httpCacheManager = httpCacheManager;
        this.keySerializer = keySerializer;
        this.config = config;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        /** @type {?} */
        const canActivate = this.httpCacheManager._canActivate(request);
        /** @type {?} */
        const cache = request.params.get('cache$');
        /** @type {?} */
        const ttl = request.params.get('ttl$');
        /** @type {?} */
        const customKey = request.params.get('key$');
        /** @type {?} */
        const bucket = request.params.get('bucket$');
        /** @type {?} */
        const localParameterCodec = request.params.get('parameterCodec$');
        /** @type {?} */
        const globalParameterCodec = this.config.parameterCodec;
        /** @type {?} */
        const parameterCodec = localParameterCodec || globalParameterCodec;
        /** @type {?} */
        const clone = cloneWithoutParams(request, customKey, parameterCodec);
        /** @type {?} */
        const key = this.keySerializer.serialize(clone);
        /** @type {?} */
        const queue = this.httpCacheManager._getQueue();
        if (this.httpCacheManager._isCacheable(canActivate, cache)) {
            bucket && ((/** @type {?} */ (bucket))).add(key);
            if (queue.has(key)) {
                return queue.get(key);
            }
            if (this.httpCacheManager.validate(key)) {
                return of(this.httpCacheManager.get(key));
            }
            /** @type {?} */
            const shared = next.handle(clone).pipe(tap((/**
             * @param {?} event
             * @return {?}
             */
            event => {
                if (event instanceof HttpResponse) {
                    /** @type {?} */
                    const cache = this.httpCacheManager._resolveResponse(event);
                    this.httpCacheManager._set(key, cache, +ttl);
                }
            })), finalize((/**
             * @return {?}
             */
            () => {
                queue.delete(key);
            })), share());
            queue.set(key, shared);
            return shared;
        }
        return next.handle(clone);
    }
}
HttpCacheInterceptor.ɵfac = function HttpCacheInterceptor_Factory(t) { return new (t || HttpCacheInterceptor)(ɵngcc0.ɵɵinject(HttpCacheManager), ɵngcc0.ɵɵinject(KeySerializer), ɵngcc0.ɵɵinject(HTTP_CACHE_CONFIG)); };
HttpCacheInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: HttpCacheInterceptor, factory: HttpCacheInterceptor.ɵfac });
/** @nocollapse */
HttpCacheInterceptor.ctorParameters = () => [
    { type: HttpCacheManager },
    { type: KeySerializer },
    { type: undefined, decorators: [{ type: Inject, args: [HTTP_CACHE_CONFIG,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HttpCacheInterceptor, [{
        type: Injectable
    }], function () { return [{ type: HttpCacheManager }, { type: KeySerializer }, { type: undefined, decorators: [{
                type: Inject,
                args: [HTTP_CACHE_CONFIG]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/httpCacheInterceptor.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpCacheInterceptorModule {
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config = {}) {
        return {
            providers: [
                { provide: HTTP_CACHE_CONFIG, useValue: Object.assign({}, defaultConfig, config) },
                { provide: KeySerializer, useClass: DefaultKeySerializer },
                { provide: HttpCacheStorage, useClass: DefaultHttpCacheStorage },
                { provide: TTLManager, useClass: DefaultTTLManager },
                { provide: HttpCacheGuard, useClass: DefaultHttpCacheGuard },
                { provide: HTTP_INTERCEPTORS, useClass: HttpCacheInterceptor, multi: true },
                HttpCacheManager,
                RequestsQueue
            ],
            ngModule: HttpCacheInterceptorModule
        };
    }
}
HttpCacheInterceptorModule.ɵfac = function HttpCacheInterceptorModule_Factory(t) { return new (t || HttpCacheInterceptorModule)(); };
HttpCacheInterceptorModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: HttpCacheInterceptorModule });
HttpCacheInterceptorModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HttpCacheInterceptorModule, [{
        type: NgModule,
        args: [{}]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/localstorage/localstorage.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} key
 * @param {?} storage
 * @return {?}
 */
function setCacheInStorage(key, storage) {
    localStorage.setItem(key, JSON.stringify(mapToObj(storage)));
}
/**
 * @param {?} key
 * @return {?}
 */
function getStorageCache(key) {
    /** @type {?} */
    const storage = JSON.parse(localStorage.getItem(key) || '{}');
    /** @type {?} */
    const map = new Map();
    Object.keys(storage).forEach((/**
     * @param {?} key
     * @return {?}
     */
    key => map.set(key, storage[key])));
    return map;
}
/**
 * @param {?} key
 * @return {?}
 */
function clearStorageCache(key) {
    localStorage.removeItem(key);
}
/**
 * @param {?} map
 * @return {?}
 */
function mapToObj(map) {
    return Array.from(map).reduce((/**
     * @param {?} obj
     * @param {?} __1
     * @return {?}
     */
    (obj, [key, value]) => {
        obj[key] = value;
        return obj;
    }), {});
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/localstorage/httpCacheLocalStorage.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class HttpCacheLocalStorage {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
        this.cache = new DefaultHttpCacheStorage();
        this.storageKey = config.localStorageKey;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    has(key) {
        return this.cache.has(key) || getStorageCache(this.storageKey).has(key);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    get(key) {
        /** @type {?} */
        const cacheValue = this.cache.get(key);
        if (cacheValue) {
            return cacheValue;
        }
        /** @type {?} */
        const value = getStorageCache(this.storageKey).get(key);
        if (value) {
            /** @type {?} */
            const response = new HttpResponse(value);
            this.cache.set(key, response);
        }
        return this.cache.get(key);
    }
    /**
     * @param {?} key
     * @param {?} response
     * @return {?}
     */
    set(key, response) {
        /** @type {?} */
        const storage = getStorageCache(this.storageKey);
        storage.set(key, response);
        setCacheInStorage(this.storageKey, storage);
        this.cache.set(key, response);
    }
    /**
     * @param {?=} key
     * @return {?}
     */
    delete(key) {
        this.cache.delete(key);
        if (!key) {
            clearStorageCache(this.storageKey);
            return;
        }
        /** @type {?} */
        const storage = getStorageCache(this.storageKey);
        if (typeof key === 'string') {
            storage.delete(key);
            setCacheInStorage(this.storageKey, storage);
            return;
        }
        deleteByRegex((/** @type {?} */ (key)), storage);
        setCacheInStorage(this.storageKey, storage);
    }
}
HttpCacheLocalStorage.ɵfac = function HttpCacheLocalStorage_Factory(t) { return new (t || HttpCacheLocalStorage)(ɵngcc0.ɵɵinject(HTTP_CACHE_CONFIG)); };
HttpCacheLocalStorage.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: HttpCacheLocalStorage, factory: HttpCacheLocalStorage.ɵfac });
/** @nocollapse */
HttpCacheLocalStorage.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [HTTP_CACHE_CONFIG,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HttpCacheLocalStorage, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [HTTP_CACHE_CONFIG]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/localstorage/localStorageTtlManager.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LocalStorageTTLManager {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
        this.ttlStorageKey = `${config.localStorageKey}TTL`;
        this.ttl = new DefaultTTLManager(config);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    isValid(key) {
        /** @type {?} */
        const valid = this.ttl.isValid(key);
        if (valid) {
            return true;
        }
        /** @type {?} */
        const localStorageTimeStamp = getStorageCache(this.ttlStorageKey).get(key);
        /** @type {?} */
        const validInStorage = localStorageTimeStamp > new Date().getTime();
        if (validInStorage) {
            this.ttl.set(key, localStorageTimeStamp - new Date().getTime());
        }
        return validInStorage;
    }
    /**
     * @param {?} key
     * @param {?=} ttl
     * @return {?}
     */
    set(key, ttl) {
        /** @type {?} */
        const resolveTTL = ttl || this.config.ttl;
        /** @type {?} */
        const storage = getStorageCache(this.ttlStorageKey);
        storage.set(key, new Date().setMilliseconds(resolveTTL));
        setCacheInStorage(this.ttlStorageKey, storage);
        this.ttl.set(key, resolveTTL);
    }
    /**
     * @param {?=} key
     * @return {?}
     */
    delete(key) {
        this.ttl.delete(key);
        if (!key) {
            clearStorageCache(this.ttlStorageKey);
            return;
        }
        if (typeof key === 'string') {
            /** @type {?} */
            const storage = getStorageCache(this.ttlStorageKey);
            storage.delete(key);
            setCacheInStorage(this.ttlStorageKey, storage);
            return;
        }
        /** @type {?} */
        const storage = getStorageCache(this.ttlStorageKey);
        deleteByRegex((/** @type {?} */ (key)), storage);
        setCacheInStorage(this.ttlStorageKey, storage);
    }
}
LocalStorageTTLManager.ɵfac = function LocalStorageTTLManager_Factory(t) { return new (t || LocalStorageTTLManager)(ɵngcc0.ɵɵinject(HTTP_CACHE_CONFIG)); };
LocalStorageTTLManager.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: LocalStorageTTLManager, factory: LocalStorageTTLManager.ɵfac });
/** @nocollapse */
LocalStorageTTLManager.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [HTTP_CACHE_CONFIG,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalStorageTTLManager, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [HTTP_CACHE_CONFIG]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/localstorage/useHttpCacheLocalStorage.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const useHttpCacheLocalStorage = [
    { provide: HttpCacheStorage, useClass: HttpCacheLocalStorage },
    { provide: TTLManager, useClass: LocalStorageTTLManager }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngneat-cashew.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { KeySerializer, DefaultKeySerializer, HttpCacheManager, HttpCacheInterceptor, HttpCacheGuard, DefaultHttpCacheGuard, withCache, cashewConfig, defaultConfig, HTTP_CACHE_CONFIG, TTLManager, DefaultTTLManager, HttpCacheStorage, DefaultHttpCacheStorage, HttpCacheInterceptorModule, CacheBucket, useHttpCacheLocalStorage, HttpCacheLocalStorage as ɵb, LocalStorageTTLManager as ɵc, RequestsQueue as ɵa };

//# sourceMappingURL=ngneat-cashew.js.map