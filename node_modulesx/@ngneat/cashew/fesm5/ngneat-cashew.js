import { of } from 'rxjs';
import { finalize, share, tap } from 'rxjs/operators';
import { HttpResponse, HttpParams, HTTP_INTERCEPTORS } from '@angular/common/http';
import { __extends, __assign, __values, __read } from 'tslib';
import { InjectionToken, Injectable, Inject, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/keySerializer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
KeySerializer = /** @class */ (function () {
    function KeySerializer() {
    }
    return KeySerializer;
}());
var DefaultKeySerializer = /** @class */ (function (_super) {
    __extends(DefaultKeySerializer, _super);
    function DefaultKeySerializer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} request
     * @return {?}
     */
    DefaultKeySerializer.prototype.serialize = /**
     * @param {?} request
     * @return {?}
     */
    function (request) {
        return request.customKey || request.urlWithParams;
    };
    return DefaultKeySerializer;
}(KeySerializer));

/**
 * @fileoverview added by tsickle
 * Generated from: lib/httpCacheConfig.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var defaultConfig = {
    strategy: 'explicit',
    ttl: 3600000,
    // One hour
    localStorageKey: 'httpCache'
};
/**
 * @param {?=} params
 * @return {?}
 */
function withCache(params) {
    if (params === void 0) { params = {}; }
    return {
        params: __assign({ cache$: true }, params)
    };
}
/**
 * @param {?=} config
 * @return {?}
 */
function cashewConfig(config) {
    if (config === void 0) { config = defaultConfig; }
    return {
        strategy: config.strategy || defaultConfig.strategy,
        ttl: config.ttl || defaultConfig.ttl,
        localStorageKey: config.localStorageKey || defaultConfig.localStorageKey,
        responseSerializer: config.responseSerializer,
        parameterCodec: config.parameterCodec
    };
}
/** @type {?} */
var HTTP_CACHE_CONFIG = new InjectionToken('HTTP_CACHE_CONFIG');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/deleteByRegex.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} pattern
 * @param {?} cache
 * @return {?}
 */
function deleteByRegex(pattern, cache) {
    var e_1, _a;
    try {
        for (var _b = __values(Array.from(cache)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 1), key = _d[0];
            if (((/** @type {?} */ (pattern))).test(key)) {
                cache.delete(key);
                break;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/httpCacheStorage.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
HttpCacheStorage = /** @class */ (function () {
    function HttpCacheStorage() {
    }
    return HttpCacheStorage;
}());
var DefaultHttpCacheStorage = /** @class */ (function () {
    function DefaultHttpCacheStorage() {
        this.cache = new Map();
    }
    /**
     * @param {?} key
     * @return {?}
     */
    DefaultHttpCacheStorage.prototype.has = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this.cache.has(key);
    };
    /**
     * @param {?} key
     * @return {?}
     */
    DefaultHttpCacheStorage.prototype.get = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this.cache.get(key);
    };
    /**
     * @param {?} key
     * @param {?} response
     * @return {?}
     */
    DefaultHttpCacheStorage.prototype.set = /**
     * @param {?} key
     * @param {?} response
     * @return {?}
     */
    function (key, response) {
        this.cache.set(key, response);
    };
    /**
     * @param {?=} key
     * @return {?}
     */
    DefaultHttpCacheStorage.prototype.delete = /**
     * @param {?=} key
     * @return {?}
     */
    function (key) {
        if (!key) {
            this.cache.clear();
            return;
        }
        if (typeof key === 'string') {
            this.cache.delete((/** @type {?} */ (key)));
            return;
        }
        deleteByRegex((/** @type {?} */ (key)), this.cache);
    };
    DefaultHttpCacheStorage.decorators = [
        { type: Injectable }
    ];
    return DefaultHttpCacheStorage;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ttlManager.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
TTLManager = /** @class */ (function () {
    function TTLManager() {
    }
    return TTLManager;
}());
var DefaultTTLManager = /** @class */ (function () {
    function DefaultTTLManager(config) {
        this.config = config;
        this.cache = new Map();
    }
    /**
     * @param {?} key
     * @return {?}
     */
    DefaultTTLManager.prototype.isValid = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this.cache.get(key) > new Date().getTime();
    };
    /**
     * @param {?} key
     * @param {?=} ttl
     * @return {?}
     */
    DefaultTTLManager.prototype.set = /**
     * @param {?} key
     * @param {?=} ttl
     * @return {?}
     */
    function (key, ttl) {
        /** @type {?} */
        var resolveTTL = ttl || this.config.ttl;
        this.cache.set(key, new Date().setMilliseconds(resolveTTL));
    };
    /**
     * @param {?=} key
     * @return {?}
     */
    DefaultTTLManager.prototype.delete = /**
     * @param {?=} key
     * @return {?}
     */
    function (key) {
        if (!key) {
            this.cache.clear();
            return;
        }
        if (typeof key === 'string') {
            this.cache.delete((/** @type {?} */ (key)));
            return;
        }
        deleteByRegex((/** @type {?} */ (key)), this.cache);
    };
    DefaultTTLManager.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    DefaultTTLManager.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [HTTP_CACHE_CONFIG,] }] }
    ]; };
    return DefaultTTLManager;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: lib/httpCacheGuard.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
HttpCacheGuard = /** @class */ (function () {
    function HttpCacheGuard() {
    }
    return HttpCacheGuard;
}());
var DefaultHttpCacheGuard = /** @class */ (function () {
    function DefaultHttpCacheGuard() {
    }
    /**
     * @param {?} request
     * @return {?}
     */
    DefaultHttpCacheGuard.prototype.canActivate = /**
     * @param {?} request
     * @return {?}
     */
    function (request) {
        return request.method === 'GET' && request.responseType === 'json';
    };
    return DefaultHttpCacheGuard;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: lib/requestsQueue.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var RequestsQueue = /** @class */ (function () {
    function RequestsQueue() {
        this.queue = new Map();
    }
    /**
     * @param {?} key
     * @return {?}
     */
    RequestsQueue.prototype.get = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this.queue.get(key);
    };
    /**
     * @param {?} key
     * @return {?}
     */
    RequestsQueue.prototype.has = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this.queue.has(key);
    };
    /**
     * @param {?} key
     * @param {?} shared
     * @return {?}
     */
    RequestsQueue.prototype.set = /**
     * @param {?} key
     * @param {?} shared
     * @return {?}
     */
    function (key, shared) {
        this.queue.set(key, shared);
    };
    /**
     * @param {?} key
     * @return {?}
     */
    RequestsQueue.prototype.delete = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        this.queue.delete(key);
    };
    RequestsQueue.decorators = [
        { type: Injectable }
    ];
    return RequestsQueue;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: lib/cacheBucket.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CacheBucket = /** @class */ (function () {
    function CacheBucket() {
        this.keys = new Set();
    }
    /**
     * @param {?} key
     * @return {?}
     */
    CacheBucket.prototype.add = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        this.keys.add(key);
    };
    /**
     * @param {?} key
     * @return {?}
     */
    CacheBucket.prototype.has = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this.keys.has(key);
    };
    /**
     * @param {?} cb
     * @return {?}
     */
    CacheBucket.prototype.forEach = /**
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        this.keys.forEach(cb);
    };
    /**
     * @param {?} key
     * @return {?}
     */
    CacheBucket.prototype.delete = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        this.keys.delete(key);
    };
    /**
     * @return {?}
     */
    CacheBucket.prototype.clear = /**
     * @return {?}
     */
    function () {
        this.keys.clear();
    };
    return CacheBucket;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: lib/httpCacheManager.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var HttpCacheManager = /** @class */ (function () {
    function HttpCacheManager(queue, storage, guard, ttlManager, config) {
        this.queue = queue;
        this.storage = storage;
        this.guard = guard;
        this.ttlManager = ttlManager;
        this.config = config;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    HttpCacheManager.prototype.validate = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        /** @type {?} */
        var has = this.storage.has(key);
        /** @type {?} */
        var isValid = this.ttlManager.isValid(key);
        if (has && isValid)
            return true;
        this.storage.delete(key);
        return false;
    };
    /**
     * @template T
     * @param {?} key
     * @return {?}
     */
    HttpCacheManager.prototype.get = /**
     * @template T
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this._resolveResponse(this.storage.get(key));
    };
    /**
     * @param {?} key
     * @return {?}
     */
    HttpCacheManager.prototype.has = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this.storage.has(key);
    };
    /**
     * @param {?} key
     * @param {?} body
     * @param {?=} __2
     * @return {?}
     */
    HttpCacheManager.prototype.set = /**
     * @param {?} key
     * @param {?} body
     * @param {?=} __2
     * @return {?}
     */
    function (key, body, _a) {
        var _b = _a === void 0 ? {} : _a, ttl = _b.ttl, bucket = _b.bucket;
        /** @type {?} */
        var response = body;
        if (!(body instanceof HttpResponse)) {
            response = new HttpResponse({
                body: body,
                status: 200,
                url: key
            });
        }
        this._set(key, response, ttl);
        bucket && bucket.add(key);
    };
    /**
     * @param {?=} key
     * @return {?}
     */
    HttpCacheManager.prototype.delete = /**
     * @param {?=} key
     * @return {?}
     */
    function (key) {
        var _this = this;
        if (key instanceof CacheBucket) {
            key.forEach((/**
             * @param {?} value
             * @return {?}
             */
            function (value) { return _this.delete(value); }));
            key.clear();
            return;
        }
        this.storage.delete(key);
        this.ttlManager.delete(key);
    };
    /**
     * @return {?}
     */
    HttpCacheManager.prototype._getQueue = /**
     * @return {?}
     */
    function () {
        return this.queue;
    };
    /**
     * @param {?} canActivate
     * @param {?} cache
     * @return {?}
     */
    HttpCacheManager.prototype._isCacheable = /**
     * @param {?} canActivate
     * @param {?} cache
     * @return {?}
     */
    function (canActivate, cache) {
        /** @type {?} */
        var strategy = this.config.strategy;
        if (strategy === 'explicit') {
            return cache;
        }
        if (canActivate && strategy === 'implicit') {
            return cache !== false;
        }
        return false;
    };
    /**
     * @param {?} key
     * @param {?} response
     * @param {?} ttl
     * @return {?}
     */
    HttpCacheManager.prototype._set = /**
     * @param {?} key
     * @param {?} response
     * @param {?} ttl
     * @return {?}
     */
    function (key, response, ttl) {
        this.storage.set(key, response);
        this.ttlManager.set(key, ttl);
    };
    /**
     * @param {?} request
     * @return {?}
     */
    HttpCacheManager.prototype._canActivate = /**
     * @param {?} request
     * @return {?}
     */
    function (request) {
        return this.guard.canActivate(request);
    };
    /**
     * @template T
     * @param {?} event
     * @return {?}
     */
    HttpCacheManager.prototype._resolveResponse = /**
     * @template T
     * @param {?} event
     * @return {?}
     */
    function (event) {
        return this.config.responseSerializer ? event.clone({ body: this.config.responseSerializer(event.body) }) : event;
    };
    HttpCacheManager.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    HttpCacheManager.ctorParameters = function () { return [
        { type: RequestsQueue },
        { type: HttpCacheStorage },
        { type: HttpCacheGuard },
        { type: TTLManager },
        { type: undefined, decorators: [{ type: Inject, args: [HTTP_CACHE_CONFIG,] }] }
    ]; };
    return HttpCacheManager;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: lib/filterParams.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var filterKeys = ['ttl$', 'cache$', 'key$', 'bucket$', 'parameterCodec$'];
/**
 * @param {?} request
 * @return {?}
 */
function filterParams(request) {
    return request.params.keys().reduce((/**
     * @param {?} acc
     * @param {?} key
     * @return {?}
     */
    function (acc, key) {
        if (filterKeys.includes(key) === false) {
            acc[key] = request.params.getAll(key);
        }
        return acc;
    }), {});
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/cloneWithoutParams.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} request
 * @param {?} customKey
 * @param {?=} parameterCodec
 * @return {?}
 */
function cloneWithoutParams(request, customKey, parameterCodec) {
    /** @type {?} */
    var filteredParams = filterParams(request);
    /** @type {?} */
    var clone = request.clone({
        params: new HttpParams(__assign({ fromObject: filteredParams }, (parameterCodec && { encoder: parameterCodec })))
    });
    ((/** @type {?} */ (clone))).customKey = customKey;
    return (/** @type {?} */ (clone));
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/httpCacheInterceptor.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var HttpCacheInterceptor = /** @class */ (function () {
    function HttpCacheInterceptor(httpCacheManager, keySerializer, config) {
        this.httpCacheManager = httpCacheManager;
        this.keySerializer = keySerializer;
        this.config = config;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    HttpCacheInterceptor.prototype.intercept = /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    function (request, next) {
        var _this = this;
        /** @type {?} */
        var canActivate = this.httpCacheManager._canActivate(request);
        /** @type {?} */
        var cache = request.params.get('cache$');
        /** @type {?} */
        var ttl = request.params.get('ttl$');
        /** @type {?} */
        var customKey = request.params.get('key$');
        /** @type {?} */
        var bucket = request.params.get('bucket$');
        /** @type {?} */
        var localParameterCodec = request.params.get('parameterCodec$');
        /** @type {?} */
        var globalParameterCodec = this.config.parameterCodec;
        /** @type {?} */
        var parameterCodec = localParameterCodec || globalParameterCodec;
        /** @type {?} */
        var clone = cloneWithoutParams(request, customKey, parameterCodec);
        /** @type {?} */
        var key = this.keySerializer.serialize(clone);
        /** @type {?} */
        var queue = this.httpCacheManager._getQueue();
        if (this.httpCacheManager._isCacheable(canActivate, cache)) {
            bucket && ((/** @type {?} */ (bucket))).add(key);
            if (queue.has(key)) {
                return queue.get(key);
            }
            if (this.httpCacheManager.validate(key)) {
                return of(this.httpCacheManager.get(key));
            }
            /** @type {?} */
            var shared = next.handle(clone).pipe(tap((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                if (event instanceof HttpResponse) {
                    /** @type {?} */
                    var cache_1 = _this.httpCacheManager._resolveResponse(event);
                    _this.httpCacheManager._set(key, cache_1, +ttl);
                }
            })), finalize((/**
             * @return {?}
             */
            function () {
                queue.delete(key);
            })), share());
            queue.set(key, shared);
            return shared;
        }
        return next.handle(clone);
    };
    HttpCacheInterceptor.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    HttpCacheInterceptor.ctorParameters = function () { return [
        { type: HttpCacheManager },
        { type: KeySerializer },
        { type: undefined, decorators: [{ type: Inject, args: [HTTP_CACHE_CONFIG,] }] }
    ]; };
    return HttpCacheInterceptor;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: lib/httpCacheInterceptor.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var HttpCacheInterceptorModule = /** @class */ (function () {
    function HttpCacheInterceptorModule() {
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    HttpCacheInterceptorModule.forRoot = /**
     * @param {?=} config
     * @return {?}
     */
    function (config) {
        if (config === void 0) { config = {}; }
        return {
            providers: [
                { provide: HTTP_CACHE_CONFIG, useValue: __assign({}, defaultConfig, config) },
                { provide: KeySerializer, useClass: DefaultKeySerializer },
                { provide: HttpCacheStorage, useClass: DefaultHttpCacheStorage },
                { provide: TTLManager, useClass: DefaultTTLManager },
                { provide: HttpCacheGuard, useClass: DefaultHttpCacheGuard },
                { provide: HTTP_INTERCEPTORS, useClass: HttpCacheInterceptor, multi: true },
                HttpCacheManager,
                RequestsQueue
            ],
            ngModule: HttpCacheInterceptorModule
        };
    };
    HttpCacheInterceptorModule.decorators = [
        { type: NgModule, args: [{},] }
    ];
    return HttpCacheInterceptorModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: lib/localstorage/localstorage.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} key
 * @param {?} storage
 * @return {?}
 */
function setCacheInStorage(key, storage) {
    localStorage.setItem(key, JSON.stringify(mapToObj(storage)));
}
/**
 * @param {?} key
 * @return {?}
 */
function getStorageCache(key) {
    /** @type {?} */
    var storage = JSON.parse(localStorage.getItem(key) || '{}');
    /** @type {?} */
    var map = new Map();
    Object.keys(storage).forEach((/**
     * @param {?} key
     * @return {?}
     */
    function (key) { return map.set(key, storage[key]); }));
    return map;
}
/**
 * @param {?} key
 * @return {?}
 */
function clearStorageCache(key) {
    localStorage.removeItem(key);
}
/**
 * @param {?} map
 * @return {?}
 */
function mapToObj(map) {
    return Array.from(map).reduce((/**
     * @param {?} obj
     * @param {?} __1
     * @return {?}
     */
    function (obj, _a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        obj[key] = value;
        return obj;
    }), {});
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/localstorage/httpCacheLocalStorage.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var HttpCacheLocalStorage = /** @class */ (function () {
    function HttpCacheLocalStorage(config) {
        this.config = config;
        this.cache = new DefaultHttpCacheStorage();
        this.storageKey = config.localStorageKey;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    HttpCacheLocalStorage.prototype.has = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this.cache.has(key) || getStorageCache(this.storageKey).has(key);
    };
    /**
     * @param {?} key
     * @return {?}
     */
    HttpCacheLocalStorage.prototype.get = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        /** @type {?} */
        var cacheValue = this.cache.get(key);
        if (cacheValue) {
            return cacheValue;
        }
        /** @type {?} */
        var value = getStorageCache(this.storageKey).get(key);
        if (value) {
            /** @type {?} */
            var response = new HttpResponse(value);
            this.cache.set(key, response);
        }
        return this.cache.get(key);
    };
    /**
     * @param {?} key
     * @param {?} response
     * @return {?}
     */
    HttpCacheLocalStorage.prototype.set = /**
     * @param {?} key
     * @param {?} response
     * @return {?}
     */
    function (key, response) {
        /** @type {?} */
        var storage = getStorageCache(this.storageKey);
        storage.set(key, response);
        setCacheInStorage(this.storageKey, storage);
        this.cache.set(key, response);
    };
    /**
     * @param {?=} key
     * @return {?}
     */
    HttpCacheLocalStorage.prototype.delete = /**
     * @param {?=} key
     * @return {?}
     */
    function (key) {
        this.cache.delete(key);
        if (!key) {
            clearStorageCache(this.storageKey);
            return;
        }
        /** @type {?} */
        var storage = getStorageCache(this.storageKey);
        if (typeof key === 'string') {
            storage.delete(key);
            setCacheInStorage(this.storageKey, storage);
            return;
        }
        deleteByRegex((/** @type {?} */ (key)), storage);
        setCacheInStorage(this.storageKey, storage);
    };
    HttpCacheLocalStorage.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    HttpCacheLocalStorage.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [HTTP_CACHE_CONFIG,] }] }
    ]; };
    return HttpCacheLocalStorage;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: lib/localstorage/localStorageTtlManager.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LocalStorageTTLManager = /** @class */ (function () {
    function LocalStorageTTLManager(config) {
        this.config = config;
        this.ttlStorageKey = config.localStorageKey + "TTL";
        this.ttl = new DefaultTTLManager(config);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    LocalStorageTTLManager.prototype.isValid = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        /** @type {?} */
        var valid = this.ttl.isValid(key);
        if (valid) {
            return true;
        }
        /** @type {?} */
        var localStorageTimeStamp = getStorageCache(this.ttlStorageKey).get(key);
        /** @type {?} */
        var validInStorage = localStorageTimeStamp > new Date().getTime();
        if (validInStorage) {
            this.ttl.set(key, localStorageTimeStamp - new Date().getTime());
        }
        return validInStorage;
    };
    /**
     * @param {?} key
     * @param {?=} ttl
     * @return {?}
     */
    LocalStorageTTLManager.prototype.set = /**
     * @param {?} key
     * @param {?=} ttl
     * @return {?}
     */
    function (key, ttl) {
        /** @type {?} */
        var resolveTTL = ttl || this.config.ttl;
        /** @type {?} */
        var storage = getStorageCache(this.ttlStorageKey);
        storage.set(key, new Date().setMilliseconds(resolveTTL));
        setCacheInStorage(this.ttlStorageKey, storage);
        this.ttl.set(key, resolveTTL);
    };
    /**
     * @param {?=} key
     * @return {?}
     */
    LocalStorageTTLManager.prototype.delete = /**
     * @param {?=} key
     * @return {?}
     */
    function (key) {
        this.ttl.delete(key);
        if (!key) {
            clearStorageCache(this.ttlStorageKey);
            return;
        }
        if (typeof key === 'string') {
            /** @type {?} */
            var storage_1 = getStorageCache(this.ttlStorageKey);
            storage_1.delete(key);
            setCacheInStorage(this.ttlStorageKey, storage_1);
            return;
        }
        /** @type {?} */
        var storage = getStorageCache(this.ttlStorageKey);
        deleteByRegex((/** @type {?} */ (key)), storage);
        setCacheInStorage(this.ttlStorageKey, storage);
    };
    LocalStorageTTLManager.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    LocalStorageTTLManager.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [HTTP_CACHE_CONFIG,] }] }
    ]; };
    return LocalStorageTTLManager;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: lib/localstorage/useHttpCacheLocalStorage.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var useHttpCacheLocalStorage = [
    { provide: HttpCacheStorage, useClass: HttpCacheLocalStorage },
    { provide: TTLManager, useClass: LocalStorageTTLManager }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngneat-cashew.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { KeySerializer, DefaultKeySerializer, HttpCacheManager, HttpCacheInterceptor, HttpCacheGuard, DefaultHttpCacheGuard, withCache, cashewConfig, defaultConfig, HTTP_CACHE_CONFIG, TTLManager, DefaultTTLManager, HttpCacheStorage, DefaultHttpCacheStorage, HttpCacheInterceptorModule, CacheBucket, useHttpCacheLocalStorage, HttpCacheLocalStorage as ɵb, LocalStorageTTLManager as ɵc, RequestsQueue as ɵa };

//# sourceMappingURL=ngneat-cashew.js.map